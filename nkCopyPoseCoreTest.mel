/*! © 2023 imaoki | MIT License | https://github.com/imaoki */

// /////////////////////////////////////////////////////////////////////////////
// 汎用プロシージャ
// /////////////////////////////////////////////////////////////////////////////
// -----------------------------------------------------------------------------
// 文字列
// -----------------------------------------------------------------------------
/*-
入力文字列を正規表現パターンに一致する部分とそれ以外に分割する。
@param $regex <string>
@param $input <string>
@returns <string[]> 一致する部分がなければ空の配列を返す。
*/
proc string[] divideString(string $regex, string $input) {
  string $substrings[];
  string $part1 = `match $regex $input`;
  if (`size $part1`) {
    string $part2 = `substitute $regex $input ""`;
    $substrings = {$part1, $part2};
  }
  return $substrings;
}

/*-
@param $procName <string>
@returns <string>
*/
proc string getScriptDir(string $procName) {
  string $scriptDir;
  string $thisIs = `whatIs $procName`;
  string $procParts[] = divideString("^Mel procedure found in: *", $thisIs);
  if (`size $procParts` != 2) {
    string $procParts[] = divideString("^Script found in: *", $thisIs);
  }
  if (`size $procParts` == 2 && `size $procParts[1]`) {
    string $scriptPath = $procParts[1];
    string $pathParts[] = divideString(
      "/" + $procName + "\\.mel$",
      $scriptPath
    );
    if (`size $pathParts` == 2 && `size $pathParts[1]`) {
      $scriptDir = $pathParts[1];
    }
  }
  return $scriptDir;
}

// -----------------------------------------------------------------------------
// 配列
// -----------------------------------------------------------------------------
/*-
@param $a <float[]>
@param $b <float[]>
@returns <int>
*/
proc int minFloatArrayCount(float $a[], float $b[]) {
  int $numA = `size $a`;
  int $numB = `size $b`;
  return `min $numA $numB`;
}

/*-
@param $a <int[]>
@param $b <int[]>
@returns <int>
*/
proc int minIntArrayCount(int $a[], int $b[]) {
  int $numA = `size $a`;
  int $numB = `size $b`;
  return `min $numA $numB`;
}

/*-
@param $a <string[]>
@param $b <string[]>
@returns <int>
*/
proc int minStringArrayCount(string $a[], string $b[]) {
  int $numA = `size $a`;
  int $numB = `size $b`;
  return `min $numA $numB`;
}

// -----------------------------------------------------------------------------
// クォータニオン
// -----------------------------------------------------------------------------
/*-
@param $degree <float>
@param $axis <float[]>
@returns <float[]>
@remarks https://github.com/mrdoob/three.js/blob/dev/LICENSE
*/
proc float[] angleAxisToQuat(float $degree, float $axis[]) {
  float $ha = `deg_to_rad $degree` * 0.5;
  float $s = sin($ha);
  float $qx = $axis[0] * $s;
  float $qy = $axis[1] * $s;
  float $qz = $axis[2] * $s;
  float $qw = cos($ha);
  return {$qx, $qy, $qz, $qw};
}

/*-
@param $order <int>
@returns <int>
*/
proc int reverseRotateOrder(int $order) {
  int $reverseOrder[] = {5, 3, 4, 1, 2, 0};
  return $reverseOrder[$order];
}

/*-
@param $r <float[]>
@param $order <int>
@returns <float[]>
@remarks https://github.com/mrdoob/three.js/blob/dev/LICENSE
*/
proc float[] eulerToQuat(float $r[], int $order) {
  float $qx = 0.0;
  float $qy = 0.0;
  float $qz = 0.0;
  float $qw = 1.0;
  float $rx = `deg_to_rad $r[0]`;
  float $ry = `deg_to_rad $r[1]`;
  float $rz = `deg_to_rad $r[2]`;
  float $cx = cos(0.5 * $rx);
  float $cy = cos(0.5 * $ry);
  float $cz = cos(0.5 * $rz);
  float $sx = sin(0.5 * $rx);
  float $sy = sin(0.5 * $ry);
  float $sz = sin(0.5 * $rz);
  switch ($order) {
    // XYZ
    case 0:
      $qx = $sx * $cy * $cz + $cx * $sy * $sz;
      $qy = $cx * $sy * $cz - $sx * $cy * $sz;
      $qz = $cx * $cy * $sz + $sx * $sy * $cz;
      $qw = $cx * $cy * $cz - $sx * $sy * $sz;
      break;
    // YZX
    case 1:
      $qx = $sx * $cy * $cz + $cx * $sy * $sz;
      $qy = $cx * $sy * $cz + $sx * $cy * $sz;
      $qz = $cx * $cy * $sz - $sx * $sy * $cz;
      $qw = $cx * $cy * $cz - $sx * $sy * $sz;
      break;
    // ZXY
    case 2:
      $qx = $sx * $cy * $cz - $cx * $sy * $sz;
      $qy = $cx * $sy * $cz + $sx * $cy * $sz;
      $qz = $cx * $cy * $sz + $sx * $sy * $cz;
      $qw = $cx * $cy * $cz - $sx * $sy * $sz;
      break;
    // XZY
    case 3:
      $qx = $sx * $cy * $cz - $cx * $sy * $sz;
      $qy = $cx * $sy * $cz - $sx * $cy * $sz;
      $qz = $cx * $cy * $sz + $sx * $sy * $cz;
      $qw = $cx * $cy * $cz + $sx * $sy * $sz;
      break;
    // YXZ
    case 4:
      $qx = $sx * $cy * $cz + $cx * $sy * $sz;
      $qy = $cx * $sy * $cz - $sx * $cy * $sz;
      $qz = $cx * $cy * $sz - $sx * $sy * $cz;
      $qw = $cx * $cy * $cz + $sx * $sy * $sz;
      break;
    // ZYX
    case 5:
      $qx = $sx * $cy * $cz - $cx * $sy * $sz;
      $qy = $cx * $sy * $cz + $sx * $cy * $sz;
      $qz = $cx * $cy * $sz - $sx * $sy * $cz;
      $qw = $cx * $cy * $cz + $sx * $sy * $sz;
      break;
    default: break;
  }
  return {$qx, $qy, $qz, $qw};
}

/*-
@param $q <float[]>
@param $order <int>
@returns <float[]>
@remarks https://github.com/aadebdeb/MatrixQuaternionEulerAngleConversions
*/
proc float[] quatToEuler(float $q[], int $order) {
  float $rx = 0.0;
  float $ry = 0.0;
  float $rz = 0.0;
  float $qx = $q[0];
  float $qy = $q[1];
  float $qz = $q[2];
  float $qw = $q[3];
  float $sx;
  float $sy;
  float $sz;
  int $unlocked;
  switch ($order) {
    // XYZ
    case 0:
      $sy = 2 * $qx * $qz + 2 * $qy * $qw;
      $unlocked = abs($sy) < 0.9999999;
      $rx = $unlocked ? atan2(-(2 * $qy * $qz - 2 * $qx * $qw), 2 * $qw * $qw + 2 * $qz * $qz - 1)
          : atan2(2 * $qy * $qz + 2 * $qx * $qw, 2 * $qw * $qw + 2 * $qy * $qy - 1);
      $ry = asin($sy);
      $rz = $unlocked ? atan2(-(2 * $qx * $qy - 2 * $qz * $qw), 2 * $qw * $qw + 2 * $qx * $qx - 1) : 0;
      break;
    // YZX
    case 1:
      $sz = 2 * $qx * $qy + 2 * $qz * $qw;
      $unlocked = abs($sz) < 0.9999999;
      $rx = $unlocked ? atan2(-(2 * $qy * $qz - 2 * $qx * $qw), 2 * $qw * $qw + 2 * $qy * $qy - 1) : 0;
      $ry = $unlocked ? atan2(-(2 * $qx * $qz - 2 * $qy * $qw), 2 * $qw * $qw + 2 * $qx * $qx - 1)
          : atan2(2 * $qx * $qz + 2 * $qy * $qw, 2 * $qw * $qw + 2 * $qz * $qz - 1);
      $rz = asin($sz);
      break;
    // ZXY
    case 2:
      $sx = 2 * $qy * $qz + 2 * $qx * $qw;
      $unlocked = abs($sx) < 0.9999999;
      $rx = asin($sx);
      $ry = $unlocked ? atan2(-(2 * $qx * $qz - 2 * $qy * $qw), 2 * $qw * $qw + 2 * $qz * $qz - 1) : 0;
      $rz = $unlocked ? atan2(-(2 * $qx * $qy - 2 * $qz * $qw), 2 * $qw * $qw + 2 * $qy * $qy - 1)
          : atan2(2 * $qx * $qy + 2 * $qz * $qw, 2 * $qw * $qw + 2 * $qx * $qx - 1);
      break;
    // XZY
    case 3:
      $sz = -(2 * $qx * $qy - 2 * $qz * $qw);
      $unlocked = abs($sz) < 0.9999999;
      $rx = $unlocked ? atan2(2 * $qy * $qz + 2 * $qx * $qw, 2 * $qw * $qw + 2 * $qy * $qy - 1)
          : atan2(-(2 * $qy * $qz - 2 * $qx * $qw), 2 * $qw * $qw + 2 * $qz * $qz - 1);
      $ry = $unlocked ? atan2(2 * $qx * $qz + 2 * $qy * $qw, 2 * $qw * $qw + 2 * $qx * $qx - 1) : 0;
      $rz = asin($sz);
      break;
    // YXZ
    case 4:
      $sx = -(2 * $qy * $qz - 2 * $qx * $qw);
      $unlocked = abs($sx) < 0.9999999;
      $rx = asin($sx);
      $ry = $unlocked ? atan2(2 * $qx * $qz + 2 * $qy * $qw, 2 * $qw * $qw + 2 * $qz * $qz - 1)
          : atan2(-(2 * $qx * $qz - 2 * $qy * $qw), 2 * $qw * $qw + 2 * $qx * $qx - 1);
      $rz = $unlocked ? atan2(2 * $qx * $qy + 2 * $qz * $qw, 2 * $qw * $qw + 2 * $qy * $qy - 1) : 0;
      break;
    // ZYX
    case 5:
      $sy = -(2 * $qx * $qz - 2 * $qy * $qw);
      $unlocked = abs($sy) < 0.9999999;
      $rx = $unlocked ? atan2(2 * $qy * $qz + 2 * $qx * $qw, 2 * $qw * $qw + 2 * $qz * $qz - 1) : 0;
      $ry = asin($sy);
      $rz = $unlocked ? atan2(2 * $qx * $qy + 2 * $qz * $qw, 2 * $qw * $qw + 2 * $qx * $qx - 1)
          : atan2(-(2 * $qx * $qy - 2 * $qz * $qw), 2 * $qw * $qw + 2 * $qy * $qy - 1);
      break;
    default: break;
  }
  $rx = `rad_to_deg $rx`;
  $ry = `rad_to_deg $ry`;
  $rz = `rad_to_deg $rz`;
  return {$rx, $ry, $rz};
}

/*-
@param $q1 <float[]>
@param $q2 <float[]>
@returns <float[]>
*/
proc float[] quatAdd(float $q1[], float $q2[]) {
  float $q1x = $q1[0];
  float $q1y = $q1[1];
  float $q1z = $q1[2];
  float $q1w = $q1[3];
  float $q2x = $q2[0];
  float $q2y = $q2[1];
  float $q2z = $q2[2];
  float $q2w = $q2[3];
  float $qx = $q1x + $q2x;
  float $qy = $q1y + $q2y;
  float $qz = $q1z + $q2z;
  float $qw = $q1w + $q2w;
  return {$qx, $qy, $qz, $qw};
}

/*-
@param $q1 <float[]>
@param $q2 <float[]>
@returns <float[]>
*/
proc float[] quatSubtract(float $q1[], float $q2[]) {
  float $q1x = $q1[0];
  float $q1y = $q1[1];
  float $q1z = $q1[2];
  float $q1w = $q1[3];
  float $q2x = $q2[0];
  float $q2y = $q2[1];
  float $q2z = $q2[2];
  float $q2w = $q2[3];
  float $qx = $q1x - $q2x;
  float $qy = $q1y - $q2y;
  float $qz = $q1z - $q2z;
  float $qw = $q1w - $q2w;
  return {$qx, $qy, $qz, $qw};
}

/*-
@param $q1 <float[]>
@param $q2 <float[]>
@returns <float[]>
@remarks https://github.com/mrdoob/three.js/blob/dev/LICENSE
*/
proc float[] quatMultiply(float $q1[], float $q2[]) {
  float $q1x = $q1[0];
  float $q1y = $q1[1];
  float $q1z = $q1[2];
  float $q1w = $q1[3];
  float $q2x = $q2[0];
  float $q2y = $q2[1];
  float $q2z = $q2[2];
  float $q2w = $q2[3];
  float $qx = $q1x * $q2w + $q1w * $q2x + $q1y * $q2z - $q1z * $q2y;
  float $qy = $q1y * $q2w + $q1w * $q2y + $q1z * $q2x - $q1x * $q2z;
  float $qz = $q1z * $q2w + $q1w * $q2z + $q1x * $q2y - $q1y * $q2x;
  float $qw = $q1w * $q2w - $q1x * $q2x - $q1y * $q2y - $q1z * $q2z;
  return {$qx, $qy, $qz, $qw};
}

/*-
@param $q <float[]>
@returns <float[]>
*/
proc float[] quatInverse(float $q[]) {
  return {$q[0] * -1, $q[1] * -1, $q[2] * -1, $q[3]};
}

/*-
@param $v <float[]>
@param $q <float[]>
@returns <float[]>
*/
proc float[] rotateVectorByQuat(float $v[], float $q[]) {
  float $iq[] = quatInverse($q);
  float $vq[] = {$v[0], $v[1], $v[2], 0};
  $vq = quatMultiply(quatMultiply($q, $vq), $iq);
  return {$vq[0], $vq[1], $vq[2]};
}

/*-
@param $q <float[]>
@param $axis <float[]>
@returns <float[]>
*/
proc float[] quatFlip(float $q[], float $axis[]) {
  float $flipQ[] = angleAxisToQuat(180.0, $axis);
  return quatMultiply($flipQ, $q);
}

// -----------------------------------------------------------------------------
// ノード
// -----------------------------------------------------------------------------
/*-
@returns <string[]>
*/
proc string[] getSelectedNodes() {
  return `ls -l -sl -typ "joint" -typ "transform"`;
}

/*-
@param $n <string>
@returns <string>
*/
proc string getParentNode(string $n) {
  string $parent;
  string $parents[] = `listRelatives -f -p $n`;
  if (`size $parents` > 0) $parent = $parents[0];
  return $parent;
}

// -----------------------------------------------------------------------------
// UIコントロール
// -----------------------------------------------------------------------------
/*-
@var <string[]> 共有のUIコントロール配列。
*/
global string $nkUIControls[];

/*-
@param $control <string[]>
@returns <>
*/
proc nkUIAppendControls(string $controls[]) {
  print("nkUIAppendControls\n");
  global string $nkUIControls[];
  for ($control in $controls) {
    $nkUIControls[`size $nkUIControls`] = $control;
  }
  print("  nkUIControls:{\n    " + stringArrayToString($nkUIControls, ",\n    ") + "\n  }\n");
}

/*-
@param $root <string>
@param $end <string> 同じウィンドウのコントロールを一括除去する場合は空文字列を指定する。
@returns <>
*/
proc nkUIRemoveControls(string $root, string $end) {
  print("nkUIRemoveControls\n");
  global string $nkUIControls[];
  string $paths[];
  for ($control in $nkUIControls) {
    string $buffer[];
    int $depth = `tokenize $control "|" $buffer`;
    string $first = ($depth > 0) ? $buffer[0] : "";
    string $last = ($depth > 0) ? $buffer[$depth - 1] : "";
    int $shouldRemove = (!`size $end`)
        ? $first == $root
        : $first == $root && $last == $end;
    if ($shouldRemove) $paths[`size $paths`] = $control;
  }
  if (`size $paths` > 0) {
    $nkUIControls = stringArrayRemove($paths, $nkUIControls);
  }
  print("  nkUIControls:{\n    " + stringArrayToString($nkUIControls, ",\n    ") + "\n  }\n");
}

/*-
@param $root <string>
@param $end <string> ウィンドウの場合は`$root`と同じ値を指定する。
@returns <string>
*/
proc string nkUIGetControl(string $root, string $end) {
  global string $nkUIControls[];
  string $path;
  for ($control in $nkUIControls) {
    string $buffer[];
    int $depth = `tokenize $control "|" $buffer`;
    string $first = ($depth > 0) ? $buffer[0] : "";
    string $last = ($depth > 0) ? $buffer[$depth - 1] : "";
    if ($first == $root && $last == $end) {
      $path = $control;
      break;
    }
  }
  return $path;
}

/*-
@param $control <string>
@returns <int>
*/
proc int[] checkBoxGrpGetEnable(string $control) {
  return `checkBoxGrp -q -en $control`;
}

/*-
@param $enable <int>
@param $control <string>
@returns <>
*/
proc checkBoxGrpSetEnable(int $enable, string $control) {
  checkBoxGrp -e -en $enable $control;
}

/*-
@param $ncb <int> チェックボックスの数。1から4まで。
@param $control <string>
@returns <int[]>
*/
proc int[] checkBoxGrpGetValues(int $ncb, string $control) {
  $ncb = `clamp 1 4 $ncb`;
  int $values[];
  if ($ncb > 0) $values[0] = `checkBoxGrp -q -v1 $control`;
  if ($ncb > 1) $values[1] = `checkBoxGrp -q -v2 $control`;
  if ($ncb > 2) $values[2] = `checkBoxGrp -q -v3 $control`;
  if ($ncb > 3) $values[3] = `checkBoxGrp -q -v4 $control`;
  return $values;
}

/*-
@param $values <int[]>
@param $control <string>
@returns <>
*/
proc checkBoxGrpSetValues(int $values[], string $control) {
  int $ncb = `size $values`;
  if ($ncb > 0) checkBoxGrp -e -v1 $values[0] $control;
  if ($ncb > 1) checkBoxGrp -e -v2 $values[1] $control;
  if ($ncb > 2) checkBoxGrp -e -v3 $values[2] $control;
  if ($ncb > 3) checkBoxGrp -e -v4 $values[3] $control;
}

/*-
@param $control <string>
@returns <int>
*/
proc int radioButtonGrpGetEnable(string $control) {
  return `radioButtonGrp -q -en $control`;
}

/*-
@param $enable <int>
@param $control <string>
@returns <>
*/
proc radioButtonGrpSetEnable(int $enable, string $control) {
  radioButtonGrp -e -en $enable $control;
}

/*-
@param $control <string>
@returns <int>
*/
proc int radioButtonGrpGetSelect(string $control) {
  return `radioButtonGrp -q -sl $control`;
}

/*-
@param $index <int>
@param $control <string>
@returns <>
*/
proc radioButtonGrpSetSelect(int $index, string $control) {
  radioButtonGrp -e -sl $index $control;
}

/*-
@param $control <string>
@returns <int>
*/
proc int textFieldGrpGetEnable(string $control) {
  return `textFieldGrp -q -en $control`;
}

/*-
@param $enable <int>
@param $control <string>
@returns <>
*/
proc textFieldGrpSetEnable(int $enable, string $control) {
  textFieldGrp -e -en $enable $control;
}

/*-
@param $control <string>
@returns <int>
*/
proc int textFieldGrpGetInsertionPosition(string $control) {
  return `textFieldGrp -q -ip $control`;
}

/*-
@param $position <int>
@param $control <string>
@returns <>
*/
proc textFieldGrpSetInsertionPosition(int $position, string $control) {
  textFieldGrp -e -ip $position $control;
}

/*-
@param $control <string>
@returns <string>
*/
proc string textFieldGrpGetText(string $control) {
  return `textFieldGrp -q -tx $control`;
}

/*-
@param $text <string>
@param $control <string>
@returns <>
*/
proc textFieldGrpSetText(string $text, string $control) {
  textFieldGrp -e -tx $text $control;
}

/*-
@param $label <string>
@param $control <string>
@returns <>
*/
proc textScrollListAppend(string $label, string $control) {
  textScrollList -e -a $label $control;
}

/*-
@param $index <int>
@param $label <string>
@param $control <string>
@returns <>
*/
proc textScrollListAppendPosition(int $index, string $label, string $control) {
  textScrollList -e -ap $index $label $control;
}

/*-
@param $control <string>
@returns <>
*/
proc textScrollListRemoveAll(string $control) {
  textScrollList -e -ra $control;
}

/*-
@param $index <int>
@param $control <string>
@returns <>
*/
proc textScrollListRemoveIndexedItem(int $index, string $control) {
  textScrollList -e -rii $index $control;
}

/*-
@param $index <int>
@param $control <string>
@returns <>
*/
proc textScrollListSetSelectIndexedItem(int $index, string $control) {
  textScrollList -e -sii $index $control;
}

/*-
@param $indices <int[]>
@param $control <string>
@returns <>
*/
proc textScrollListSetSelectIndexedItems(int $indices[], string $control) {
  for ($i in $indices) {
    textScrollList -e -sii $i $control;
  }
}

/*-
@param $control <string>
@returns <int[]>
*/
proc int[] textScrollListGetSelectIndexedItems(string $control) {
  return `textScrollList -q -sii $control`;
}

/*-
@param $control <string>
@returns <int>
*/
proc int textScrollListGetSelectIndexedItem(string $control) {
  int $indices[] = textScrollListGetSelectIndexedItems($control);
  return ((`size $indices`) ? $indices[0] : 0);
}

// /////////////////////////////////////////////////////////////////////////////
// コアプロシージャ
// /////////////////////////////////////////////////////////////////////////////
/*-
@var <string[]>
```ebnf
            pose = '"' , pose_name , "=" , pose_transforms , '"' ;
       pose_name = { any_char - "=" } ;
 pose_transforms = { pose_transform }+ ;
  pose_transform = transform_header , transform_values , ";" ;
transform_header = transform_node , "[" , pose_setting , "]" ;
  transform_node = [ "|" ] , node_name , { "|" , node_name } ;
       node_name = letter , { letter | digit | "_" } ;
    pose_setting = paste_setting , "/" , select_setting , "/" , mirror_setting ;
   paste_setting = bool , "," , bool , "," , bool ;
  select_setting = select_pattern , "," , select_pattern ;
  mirror_setting = axis , "," , axis , "," , axis , "," , bool , "," , bool ;
  select_pattern = { letter | digit | "_" }+ ;
            axis = ? 0-2 ? ;
            bool = ? 0-1 ? ;
transform_values = t , "," , q , "," , s , "," , h ;
               t = number , "," , number , "," , number ;
               q = number , "," , number , "," , number , "," , number ;
               s = number , "," , number , "," , number ;
               h = number , "," , number , "," , number ;
          number = [ "-" ] , ( integer | real ) ;
           digit = ? 0-9 ? ;
          letter = ? a-zA-Z ? ;
        any_char = ? Any visible characters ? ;
```
*/
global string $nkCopyPosePoses[];

/*-
@var <int[]>
*/
global int $nkCopyPoseInitPasteSetting[];
if (!`size $nkCopyPoseInitPasteSetting`) {
  $nkCopyPoseInitPasteSetting = {1, 1, 0};
}

/*-
@var <string[]>
*/
global string $nkCopyPoseInitSelectSetting[];
if (!`size $nkCopyPoseInitSelectSetting`) {
  $nkCopyPoseInitSelectSetting = {"_L", "_R"};
}

/*-
@var <int[]>
*/
global int $nkCopyPoseInitMirrorSetting[];
if (!`size $nkCopyPoseInitMirrorSetting`) {
  $nkCopyPoseInitMirrorSetting = {0, 0, 1, 0, 0};
}

// -----------------------------------------------------------------------------
// トランスフォーム
// -----------------------------------------------------------------------------
/*-
@param $n <string>
@param $poseSetting <string>
@returns <string>
*/
proc string makeTransformHeader(string $n, string $poseSetting) {
  return ($n + "[" + $poseSetting + "]");
}

/*-
@param $n <string>
@returns <float[]>
*/
proc float[] makeTransformValues(string $n) {
  print("makeTransformValues\n");
  print("  n:" + $n + "\n");
  float $values[] = {
    0, 0, 0,
    0, 0, 0, 1,
    1, 1, 1,
    0, 0, 0
  };
  string $type = `nodeType $n`;
  if ($type == "transform" || $type == "joint") {
    float $t[] = `getAttr ($n + ".translate")`;
    float $r[] = `getAttr ($n + ".rotate")`;
    float $s[] = `getAttr ($n + ".scale")`;
    float $h[] = `getAttr ($n + ".shear")`;
    print("  t :{" + floatArrayToString($t, ", ") + "}\n");
    print("  r :{" + floatArrayToString($r, ", ") + "}\n");
    print("  s :{" + floatArrayToString($s, ", ") + "}\n");
    print("  h :{" + floatArrayToString($h, ", ") + "}\n");

    int $o = `getAttr ($n + ".rotateOrder")`;
    $o = reverseRotateOrder($o);
    int $oXYZ = reverseRotateOrder(0);

    float $rq[] = eulerToQuat($r, $o);

    float $ra[] = `getAttr ($n + ".rotateAxis")`;
    $ra = eulerToQuat($ra, $oXYZ);

    float $jo[] = {0, 0, 0, 1};
    if (`attributeQuery -n $n -ex "jointOrient"`) {
      $jo = `getAttr ($n + ".jointOrient")`;
      $jo = eulerToQuat($jo, $oXYZ);
    }

    float $q[] = quatMultiply($jo, quatMultiply($ra, $rq));

    print("  o :" + $o + "\n");
    print("  rq:{" + floatArrayToString($rq, ", ") + "}\n");
    print("  ra:{" + floatArrayToString($ra, ", ") + "}\n");
    print("  jo:{" + floatArrayToString($jo, ", ") + "}\n");
    print("  q :{" + floatArrayToString($q, ", ") + "}\n");

    $values = {
      $t[0], $t[1], $t[2],
      $q[0], $q[1], $q[2], $q[3],
      $s[0], $s[1], $s[2],
      $h[0], $h[1], $h[2]
    };
  }
  return $values;
}

/*-
@param $header <string>
@param $values <float[]>
@returns <string>
*/
proc string makePoseTransform(string $header, float $values[]) {
  return ($header + floatArrayToString($values, ",") + ";");
}

/*-
@param $nodes <string[]>
@param $poseSettings <string[]>
@returns <string[]>
*/
proc string[] generatePoseTransforms(string $nodes[], string $poseSettings[]) {
  print("generatePoseTransforms\n");
  print("  nodes       :{\n    " + stringArrayToString($nodes, ",\n    ") + "\n  }\n");
  print("  poseSettings:{\n    " + stringArrayToString($poseSettings, ",\n    ") + "\n  }\n");
  string $poseTransforms[];
  int $numTransforms = minStringArrayCount($nodes, $poseSettings);
  for ($i = 0; $i < $numTransforms; $i++) {
    string $n = $nodes[$i];
    print("  n:" + $n + "\n");
    string $header = makeTransformHeader($n, $poseSettings[$i]);
    float $values[] = makeTransformValues($n);
    string $poseTransform = makePoseTransform($header, $values);
    print("    poseTransform:" + $poseTransform + "\n");
    $poseTransforms[$i] = $poseTransform;
  }
  return $poseTransforms;
}

/*-
@param $n <string>
@param $m <float[]>
@param $shouldSetT <int>
@param $shouldSetR <int>
@param $shouldSetS <int>
@returns <>
*/
proc setTransformAttributes(
  string $n,
  float $m[],
  int $shouldApplyT,
  int $shouldApplyR,
  int $shouldApplyS
) {
  print("setTransformAttributes\n");
  print("  n           :" + $n + "\n");
  print("  m           :{" + floatArrayToString($m, ", ") + "}\n");
  print("  shouldApplyT:" + $shouldApplyT + "\n");
  print("  shouldApplyR:" + $shouldApplyR + "\n");
  print("  shouldApplyS:" + $shouldApplyS + "\n");
  if (`objExists $n` && `size $m` == 12) {
    float $t[] = {$m[0], $m[1], $m[2]};
    float $r[] = {$m[3], $m[4], $m[5]};
    float $s[] = {$m[6], $m[7], $m[8]};
    float $h[] = {$m[9], $m[10], $m[11]};
    print("  t:{" + floatArrayToString($t, ", ") + "}\n");
    print("  r:{" + floatArrayToString($r, ", ") + "}\n");
    print("  s:{" + floatArrayToString($s, ", ") + "}\n");
    print("  h:{" + floatArrayToString($h, ", ") + "}\n");

    string $tx = $n + ".tx";
    string $ty = $n + ".ty";
    string $tz = $n + ".tz";
    string $rx = $n + ".rx";
    string $ry = $n + ".ry";
    string $rz = $n + ".rz";
    string $sx = $n + ".sx";
    string $sy = $n + ".sy";
    string $sz = $n + ".sz";

    if ($shouldApplyT) {
      if (!`getAttr -l $tx`) setAttr $tx $t[0];
      if (!`getAttr -l $ty`) setAttr $ty $t[1];
      if (!`getAttr -l $tz`) setAttr $tz $t[2];
    }
    if ($shouldApplyR) {
      if (!`getAttr -l $rx`) setAttr $rx $r[0];
      if (!`getAttr -l $ry`) setAttr $ry $r[1];
      if (!`getAttr -l $rz`) setAttr $rz $r[2];
    }
    if ($shouldApplyS) {
      if (!`getAttr -l $sx`) setAttr $sx $s[0];
      if (!`getAttr -l $sy`) setAttr $sy $s[1];
      if (!`getAttr -l $sz`) setAttr $sz $s[2];
    }
  }
}

/*-
@param $n <string>
@param $m <float[]>
@returns <float[]>
*/
proc float[] asIsTransform(string $n, float $m[]) {
  print("asIsTransform\n");
  print("  n :" + $n + "\n");
  print("  m :{" + floatArrayToString($m, ", ") + "}\n");

  float $t[] = {$m[0], $m[1], $m[2]};
  float $q[] = {$m[3], $m[4], $m[5], $m[6]};
  float $s[] = {$m[7], $m[8], $m[9]};
  float $h[] = {$m[10], $m[11], $m[12]};
  print("  t :{" + floatArrayToString($t, ", ") + "}\n");
  print("  q :{" + floatArrayToString($q, ", ") + "}\n");
  print("  s :{" + floatArrayToString($s, ", ") + "}\n");
  print("  h :{" + floatArrayToString($h, ", ") + "}\n");

  int $o = `getAttr ($n + ".rotateOrder")`;
  $o = reverseRotateOrder($o);
  int $oXYZ = reverseRotateOrder(0);

  float $ra[] = `getAttr ($n + ".rotateAxis")`;
  $ra = quatInverse(eulerToQuat($ra, $oXYZ));

  float $jo[] = {0, 0, 0, 1};
  if (`attributeQuery -n $n -ex "jointOrient"`) {
    $jo = `getAttr ($n + ".jointOrient")`;
    $jo = quatInverse(eulerToQuat($jo, $oXYZ));
  }

  float $rq[] = quatMultiply($jo, quatMultiply($ra, $q));
  float $r[] = quatToEuler($rq, $o);

  print("  o :" + $o + "\n");
  print("  q :{" + floatArrayToString($q, ", ") + "}\n");
  print("  ra:{" + floatArrayToString($ra, ", ") + "}\n");
  print("  jo:{" + floatArrayToString($jo, ", ") + "}\n");
  print("  rq:{" + floatArrayToString($rq, ", ") + "}\n");
  print("  r :{" + floatArrayToString($r, ", ") + "}\n");

  float $values[] = {
    $t[0], $t[1], $t[2],
    $r[0], $r[1], $r[2],
    $s[0], $s[1], $s[2],
    $h[0], $h[1], $h[2]
  };
  print("  values:{" + floatArrayToString($values, ", ") + "}\n");

  return $values;
}

/*-
@param $n <string>
@param $m <float[]>
@param $hasCommonParent <boolean>
@param $mirrorAxis <int>
@param $primaryAxis <int>
@param $secondaryAxis <int>
@param $invertPrimaryAxis <boolean>
@param $invertSecondaryAxis <boolean>
@returns <float[]>
*/
proc float[] mirrorTransform(
  string $n,
  float $m[],
  int $hasCommonParent,
  int $mirrorAxis,
  int $primaryAxis,
  int $secondaryAxis,
  int $invertPrimaryAxis,
  int $invertSecondaryAxis
) {
  print("mirrorTransform\n");
  print("  n                  :" + $n + "\n");
  print("  m                  :{" + floatArrayToString($m, ", ") + "}\n");
  print("  hasCommonParent    :" + $hasCommonParent + "\n");
  print("  mirrorAxis         :" + $mirrorAxis + "\n");
  print("  primaryAxis        :" + $primaryAxis + "\n");
  print("  secondaryAxis      :" + $secondaryAxis + "\n");
  print("  invertPrimaryAxis  :" + $invertPrimaryAxis + "\n");
  print("  invertSecondaryAxis:" + $invertSecondaryAxis + "\n");

  float $t[] = {$m[0], $m[1], $m[2]};
  float $q[] = {$m[3], $m[4], $m[5], $m[6]};
  float $s[] = {$m[7], $m[8], $m[9]};
  float $h[] = {$m[10], $m[11], $m[12]};
  print("  t :{" + floatArrayToString($t, ", ") + "}\n");
  print("  q :{" + floatArrayToString($q, ", ") + "}\n");
  print("  s :{" + floatArrayToString($s, ", ") + "}\n");
  print("  h :{" + floatArrayToString($h, ", ") + "}\n");

  // 位置のミラーリング
  if ($hasCommonParent) {
    $t[$mirrorAxis] *= -1;
  }
  else {
    if ($invertPrimaryAxis) $t[$primaryAxis] *= -1;
    if ($invertSecondaryAxis) $t[$secondaryAxis] *= -1;
    if ($invertPrimaryAxis == $invertSecondaryAxis) {
      // 第三の軸を反転
      int $usedAxis[];
      $usedAxis[$primaryAxis] = 1;
      $usedAxis[$secondaryAxis] = 1;
      int $i;
      for ($i = 0; $i < 3; $i++) if (!$usedAxis[$i]) break;
      $t[$i] *= -1;
    }
  }

  // 回転のミラーリング
  int $o = `getAttr ($n + ".rotateOrder")`;
  $o = reverseRotateOrder($o);
  int $oXYZ = reverseRotateOrder(0);

  float $ra[] = `getAttr ($n + ".rotateAxis")`;
  $ra = quatInverse(eulerToQuat($ra, $oXYZ));

  float $jo[] = {0, 0, 0, 1};
  if (`attributeQuery -n $n -ex "jointOrient"`) {
    $jo = `getAttr ($n + ".jointOrient")`;
    $jo = quatInverse(eulerToQuat($jo, $oXYZ));
  }

  float $mq[] = $q;
  $mq[$mirrorAxis] *= -1;
  $mq[3] *= -1;
  float $cq[] = quatMultiply($jo, quatMultiply($ra, $mq));

  print("  o :" + $o + "\n");
  print("  q :{" + floatArrayToString($q, ", ") + "}\n");
  print("  ra:{" + floatArrayToString($ra, ", ") + "}\n");
  print("  jo:{" + floatArrayToString($jo, ", ") + "}\n");
  print("  mq:{" + floatArrayToString($mq, ", ") + "}\n");

  // ソースとターゲットの親が異なる場合は親ノードの反転をリセットしておく
  if (!$hasCommonParent) {
    if ($mirrorAxis == $primaryAxis || $mirrorAxis == $secondaryAxis) {
      float $flipAxis[] = {0, 0, 0};
      if ($mirrorAxis == $primaryAxis) {
        $flipAxis[$secondaryAxis] = 1;
      }
      else if ($mirrorAxis == $secondaryAxis) {
        $flipAxis[$primaryAxis] = 1;
      }
      $cq = quatFlip($cq, $flipAxis);
    }
    if ($invertPrimaryAxis) {
      float $flipAxis[] = {0, 0, 0};
      $flipAxis[$secondaryAxis] = 1;
      $cq = quatFlip($cq, $flipAxis);
    }
    if ($invertSecondaryAxis) {
      float $flipAxis[] = {0, 0, 0};
      $flipAxis[$primaryAxis] = 1;
      $cq = quatFlip($cq, $flipAxis);
    }
  }

  // プライマリとセカンダリを対称化するための反転
  if ($mirrorAxis == $primaryAxis || $mirrorAxis == $secondaryAxis) {
    float $flipAxis[] = {0, 0, 0};
    if ($mirrorAxis == $primaryAxis) {
      $flipAxis[$secondaryAxis] = 1;
    }
    else if ($mirrorAxis == $secondaryAxis) {
      $flipAxis[$primaryAxis] = 1;
    }
    $flipAxis = rotateVectorByQuat($flipAxis, $cq);
    $cq = quatFlip($cq, $flipAxis);
  }

  // 任意の反転
  if ($invertPrimaryAxis) {
    float $flipAxis[] = {0, 0, 0};
    $flipAxis[$secondaryAxis] = 1;
    $flipAxis = rotateVectorByQuat($flipAxis, $cq);
    $cq = quatFlip($cq, $flipAxis);
  }
  if ($invertSecondaryAxis) {
    float $flipAxis[] = {0, 0, 0};
    $flipAxis[$primaryAxis] = 1;
    $flipAxis = rotateVectorByQuat($flipAxis, $cq);
    $cq = quatFlip($cq, $flipAxis);
  }

  float $r[] = quatToEuler($cq, $o);
  print("  cq:{" + floatArrayToString($cq, ", ") + "}\n");
  print("  r :{" + floatArrayToString($r, ", ") + "}\n");

  float $values[] = {
    $t[0], $t[1], $t[2],
    $r[0], $r[1], $r[2],
    $s[0], $s[1], $s[2],
    $h[0], $h[1], $h[2]
  };
  print("  values:{" + floatArrayToString($values, ", ") + "}\n");

  return $values;
}

// -----------------------------------------------------------------------------
// データ変換
// -----------------------------------------------------------------------------
/*-
@param $pasteSetting <int[]>
@param $selectSetting <string[]>
@param $mirrorSetting <int[]>
@returns <string>
*/
proc string buildPoseSetting(
  int $pasteSetting[],
  string $selectSetting[],
  int $mirrorSetting[]
) {
  string $poseSetting = intArrayToString($pasteSetting, ",");
  $poseSetting += "/" + stringArrayToString($selectSetting, ",");
  $poseSetting += "/" + intArrayToString($mirrorSetting, ",");
  return $poseSetting;
}

/*-
@param $poseName <string>
@param $poseTransforms <string[]>
@returns <string>
*/
proc string buildPose(
  string $poseName,
  string $poseTransforms[]
) {
  string $pose = $poseName + "=";
  for ($poseTransform in $poseTransforms) {
    $pose += $poseTransform;
  }
  return $pose;
}

/*-
@param $pose <string>
@returns <string>
*/
proc string extractPoseName(string $pose) {
  string $poseName;
  string $buffer[];
  if (`tokenize $pose "=" $buffer` == 2) {
    $poseName = $buffer[0];
  }
  return $poseName;
}

/*-
@param $pose <string>
@returns <string[]>
*/
proc string[] extractPoseTransforms(string $pose) {
  string $poseTransforms[];
  string $buffer1[];
  if (`tokenize $pose "=" $buffer1` == 2) {
    string $buffer2[];
    if (`tokenize $buffer1[1] ";" $buffer2` > 0) {
      $poseTransforms = $buffer2;
    }
  }
  return $poseTransforms;
}

/*-
@param $poseTransform <string>
@returns <string[]>
*/
proc string[] extractTransformHeader(string $poseTransform) {
  string $header[];
  string $buffer1[];
  if (`tokenize $poseTransform "]" $buffer1` == 2) {
    string $buffer2[];
    if (`tokenize $buffer1[0] "[" $buffer2` == 2) {
      $header = $buffer2;
    }
  }
  return $header;
}

/*-
@param $poseTransform <string>
@returns <string>
*/
proc string extractTransformNode(string $poseTransform) {
  string $node;
  string $header[] = extractTransformHeader($poseTransform);
  if (`size $header` == 2) $node = $header[0];
  return $node;
}

/*-
@param $poseTransform <string>
@returns <string>
*/
proc string extractPoseSetting(string $poseTransform) {
  string $poseSetting;
  string $header[] = extractTransformHeader($poseTransform);
  if (`size $header` == 2) $poseSetting = $header[1];
  return $poseSetting;
}

/*-
@param $poseSetting <string>
@returns <string[]>
*/
proc string[] extractPoseSettings(string $poseSetting) {
  string $poseSettings[];
  string $buffer[];
  if (`tokenize $poseSetting "/" $buffer` == 3) {
    $poseSettings = $buffer;
  }
  return $poseSettings;
}

/*-
@param $poseSetting <string>
@returns <int[]>
*/
proc int[] extractPasteSetting(string $poseSetting) {
  int $pasteSetting[] = {1, 1, 0};
  string $poseSettings[] = extractPoseSettings($poseSetting);
  string $buffer[];
  if (`tokenize $poseSettings[0] "," $buffer` == 3) {
    for ($i = 0; $i < 3; $i++) {
      $pasteSetting[$i] = (int) $buffer[$i];
    }
  }
  return $pasteSetting;
}

/*-
@param $poseSetting <string>
@returns <string[]>
*/
proc string[] extractSelectSetting(string $poseSetting) {
  string $selectSetting[] = {"_L", "_R"};
  string $poseSettings[] = extractPoseSettings($poseSetting);
  string $buffer[];
  if (`tokenize $poseSettings[1] "," $buffer` == 2) {
    for ($i = 0; $i < 2; $i++) {
      $selectSetting[$i] = $buffer[$i];
    }
  }
  return $selectSetting;
}

/*-
@param $poseSetting <string>
@returns <int[]>
*/
proc int[] extractMirrorSetting(string $poseSetting) {
  int $mirrorSetting[] = {0, 0, 1, 0, 0};
  string $poseSettings[] = extractPoseSettings($poseSetting);
  string $buffer[];
  if (`tokenize $poseSettings[2] "," $buffer` == 5) {
    for ($i = 0; $i < 5; $i++) {
      $mirrorSetting[$i] = (int) $buffer[$i];
    }
  }
  return $mirrorSetting;
}

/*-
@param $poseTransform <string>
@returns <float[]>
*/
proc float[] extractTransformValues(string $poseTransform) {
  float $values[] = {
    0, 0, 0,
    0, 0, 0, 1,
    1, 1, 1,
    0, 0, 0
  };
  string $buffer1[];
  if (`tokenize $poseTransform "]" $buffer1` == 2) {
    string $buffer2[];
    if (`tokenize $buffer1[1] "," $buffer2` == 13) {
      for ($i = 0; $i < 13; $i++) {
        $values[$i] = (float) $buffer2[$i];
      }
    }
  }
  return $values;
}

// -----------------------------------------------------------------------------
// ポーズ
// -----------------------------------------------------------------------------
/*-
@returns <>
*/
proc clearPoses() {
  global string $nkCopyPosePoses[];
  clear $nkCopyPosePoses;
}

/*-
@returns <int>
*/
proc int getNumPoses() {
  global string $nkCopyPosePoses[];
  return `size $nkCopyPosePoses`;
}

/*-
@param $i <int>
@returns <string>
*/
proc string getPose(int $i) {
  global string $nkCopyPosePoses[];
  string $pose;
  if ($i >= 0 && $i < (getNumPoses())) {
    $pose = $nkCopyPosePoses[$i];
  }
  return $pose;
}

/*-
@returns <string[]>
*/
proc string[] getPoseNames() {
  global string $nkCopyPosePoses[];
  string $poseNames[];
  for ($pose in $nkCopyPosePoses) {
    $poseNames[`size $poseNames`] = extractPoseName($pose);
  }
  return $poseNames;
}

/*-
@param $poseName <string>
@param $nodes <string[]>
@param $poseSettings <string[]>
@returns <int> 追加後のポーズ数。
*/
proc int addPose(
  string $poseName,
  string $nodes[],
  string $poseSettings[]
) {
  print("addPose\n");
  print("  poseName    :" + $poseName + "\n");
  print("  nodes       :{\n    " + stringArrayToString($nodes, ",\n    ") + "\n  }\n");
  print("  poseSettings:{\n    " + stringArrayToString($poseSettings, ",\n    ") + "\n  }\n");
  global string $nkCopyPosePoses[];
  string $poseTransforms[] = generatePoseTransforms($nodes, $poseSettings);
  print("  poseTransforms:{\n    " + (stringArrayToString($poseTransforms, ",\n    ")) + "\n  }\n");
  string $pose = buildPose(
    $poseName,
    $poseTransforms
  );
  print("  pose:" + $pose + "\n");
  $nkCopyPosePoses[(getNumPoses())] = $pose;
  return (getNumPoses());
}

/*-
@param $poseIndex <int>
@returns <int> 削除後のポーズ数。
*/
proc int deletePose(int $poseIndex) {
  print("deletePose\n");
  print("  poseIndex:" + $poseIndex + "\n");
  global string $nkCopyPosePoses[];
  stringArrayRemoveAtIndex($poseIndex, $nkCopyPosePoses);
  return (getNumPoses());
}

/*-
@param $poseIndex <int>
@returns <>
*/
proc updatePose(
  int $poseIndex
) {
  print("updatePose\n");
  print("  poseIndex:" + $poseIndex + "\n");
  global string $nkCopyPosePoses[];

  string $pose = getPose($poseIndex);
  if (!`size $pose`) return;

  string $poseName = extractPoseName($pose);
  print("  poseName      :" + $poseName + "\n");

  string $poseTransforms[] = extractPoseTransforms($pose);
  print("  poseTransforms:{\n    " + stringArrayToString($poseTransforms, ",\n    ") + "\n  }\n");
  if (!`size $poseTransforms`) return;

  string $nodes[];
  string $poseSettings[];
  for ($i = 0; $i < `size $poseTransforms`; $i++) {
    string $poseTransform = $poseTransforms[$i];
    print("  poseTransform:" + $poseTransform + "\n");
    string $node = extractTransformNode($poseTransform);
    print("    node       :" + $node + "\n");
    string $poseSetting = extractPoseSetting($poseTransform);
    print("    poseSetting:" + $poseSetting + "\n");
    $nodes[$i] = $node;
    $poseSettings[$i] = $poseSetting;
  }

  string $newPoseTransforms[] = generatePoseTransforms($nodes, $poseSettings);
  print("  newPoseTransforms:{\n    " + (stringArrayToString($newPoseTransforms, ",\n    ")) + "\n  }\n");

  string $newPose = buildPose(
    $poseName,
    $newPoseTransforms
  );
  print("  newPose:" + $newPose + "\n");
  $nkCopyPosePoses[$poseIndex] = $newPose;
}

/*-
@param $poseIndex <int>
@param $poseName <string>
@param $poseSettings <string[]>
@returns <>
*/
proc editPose(
  int $poseIndex,
  string $poseName,
  string $poseSettings[]
) {
  print("editPose\n");
  print("  poseIndex   :" + $poseIndex + "\n");
  print("  poseName    :" + $poseName + "\n");
  print("  poseSettings:{\n    " + stringArrayToString($poseSettings, ",\n    ") + "\n  }\n");
  global string $nkCopyPosePoses[];

  string $pose = getPose($poseIndex);
  if (!`size $pose`) return;

  string $poseTransforms[] = extractPoseTransforms($pose);
  print("  poseTransforms:{\n    " + stringArrayToString($poseTransforms, ",\n    ") + "\n  }\n");
  if (!`size $poseTransforms`) return;

  int $numTransforms = minStringArrayCount($poseSettings, $poseTransforms);

  string $newPoseTransforms[];
  for ($i = 0; $i < $numTransforms; $i++) {
    string $poseTransform = $poseTransforms[$i];
    print("  poseTransform:" + $poseTransform + "\n");
    string $n = extractTransformNode($poseTransform);
    print("    n               :" + $n + "\n");
    string $header = makeTransformHeader($n, $poseSettings[$i]);
    print("    header          :" + $header + "\n");
    float $values[] = extractTransformValues($poseTransform);
    print("    values          :{" + floatArrayToString($values, ", ") + "}\n");
    string $newPoseTransform = makePoseTransform($header, $values);
    print("    newPoseTransform:" + $newPoseTransform + "\n");
    $newPoseTransforms[$i] = $newPoseTransform;
  }
  print("  newPoseTransforms:{\n    " + (stringArrayToString($newPoseTransforms, ",\n    ")) + "\n  }\n");

  string $newPose = buildPose(
    $poseName,
    $newPoseTransforms
  );
  print("  newPose:" + $newPose + "\n");
  $nkCopyPosePoses[$poseIndex] = $newPose;
}

/*-
@param $poseIndex <int>
@returns <int> 移動後のポーズインデックス。基数は`0`。
*/
proc int moveUpPose(int $poseIndex) {
  print("moveUpPose\n");
  print("  poseIndex:" + $poseIndex + "\n");
  global string $nkCopyPosePoses[];
  string $pose = getPose($poseIndex);
  if (!`size $pose`) return $poseIndex;
  int $newPoseIndex = $poseIndex - 1;
  print("  newPoseIndex:" + $newPoseIndex + "\n");
  stringArrayRemoveAtIndex($poseIndex, $nkCopyPosePoses);
  stringArrayInsertAtIndex($newPoseIndex, $nkCopyPosePoses, $pose);
  return $newPoseIndex;
}

/*-
@param $poseIndex <int>
@returns <int> 移動後のポーズインデックス。基数は`0`。
*/
proc int moveDownPose(int $poseIndex) {
  print("moveDownPose\n");
  print("  poseIndex:" + $poseIndex + "\n");
  global string $nkCopyPosePoses[];
  string $pose = getPose($poseIndex);
  if (!`size $pose`) return $poseIndex;
  int $newPoseIndex = $poseIndex + 1;
  print("  newPoseIndex:" + $newPoseIndex + "\n");
  stringArrayRemoveAtIndex($poseIndex, $nkCopyPosePoses);
  stringArrayInsertAtIndex($newPoseIndex, $nkCopyPosePoses, $pose);
  return $newPoseIndex;
}

/*-
@param $poseIndex <int>
@param $isOpposite <boolean>
@returns <>
*/
proc selectNodes(int $poseIndex, int $isOpposite) {
  print("selectNodes\n");
  print("  poseIndex :" + $poseIndex + "\n");
  print("  isOpposite:" + $isOpposite + "\n");

  string $pose = getPose($poseIndex);
  print("  pose:" + $pose + "\n");
  if (!`size $pose`) return;

  string $poseTransforms[] = extractPoseTransforms($pose);
  print("  poseTransforms:{\n    " + stringArrayToString($poseTransforms, ",\n    ") + "\n  }\n");
  if (!`size $poseTransforms`) return;

  string $targetNodes[];
  for ($poseTransform in $poseTransforms) {
    print("  poseTransform:" + $poseTransform + "\n");
    string $targetNode = extractTransformNode($poseTransform);
    print("    targetNode   :" + $targetNode + "\n");
    string $poseSetting = extractPoseSetting($poseTransform);
    print("    poseSetting  :" + $poseSetting + "\n");
    string $selectSetting[] = extractSelectSetting($poseSetting);
    print("    selectSetting:{" + stringArrayToString($selectSetting, ", ") + "}\n");
    string $patternA = $selectSetting[0];
    string $patternB = $selectSetting[1];
    print("    patternA     :" + $patternA + "\n");
    print("    patternB     :" + $patternB + "\n");
    if ($isOpposite) {
      if (`gmatch $targetNode ("*" + $patternA + "*")`) {
        $targetNode = substituteAllString($targetNode, $patternA, $patternB);
      }
      else if (`gmatch $targetNode ("*" + $patternB + "*")`) {
        $targetNode = substituteAllString($targetNode, $patternB, $patternA);
      }
    }
    if (`objExists $targetNode`) {
      $targetNodes[`size $targetNodes`] = $targetNode;
    }
  }
  print("  targetNodes:{\n    " + stringArrayToString($targetNodes, "\n    ") + "\n  }\n");
  if (!`size $targetNodes`) return;

  int $mods = `getModifiers`;
  print("  mods:" + $mods + "\n");
  switch ($mods) {
    // Nothing
    case 0: select -r $targetNodes; break;
    // Shift
    case 1: select -tgl $targetNodes; break;
    // Ctrl
    case 4: select -d $targetNodes; break;
    // Shift + Ctrl
    case 5: select -add $targetNodes; break;
    default: break;
  }
}

/*-
@param $poseIndex <int>
@param $isOpposite <boolean>
@param $nodes <string[]>
@returns <>
*/
proc pastePose(int $poseIndex, int $isOpposite, string $nodes[]) {
  print("pastePose\n");
  print("  poseIndex :" + $poseIndex + "\n");
  print("  isOpposite:" + $isOpposite + "\n");
  print("  nodes     :{\n    " + stringArrayToString($nodes, ",\n    ") + "\n  }\n");

  if (!`size $nodes`) return;

  string $pose = getPose($poseIndex);
  print("  pose:" + $pose + "\n");
  if (!`size $pose`) return;

  string $poseTransforms[] = extractPoseTransforms($pose);
  print("  poseTransforms:{\n    " + stringArrayToString($poseTransforms, ",\n    ") + "\n  }\n");
  if (!`size $poseTransforms`) return;

  int $numTargets = minStringArrayCount($nodes, $poseTransforms);
  print("  numTargets:" + $numTargets + "\n");

  for ($i = 0; $i < $numTargets; $i++) {
    string $poseTransform = $poseTransforms[$i];
    print("  poseTransform:" + $poseTransform + "\n");
    string $sourceNode = extractTransformNode($poseTransform);
    print("    sourceNode     :" + $sourceNode + "\n");
    string $targetNode = $nodes[$i];
    print("    targetNode     :" + $targetNode + "\n");

    float $transformValues[] = extractTransformValues($poseTransform);
    print("    transformValues:{" + floatArrayToString($transformValues, ", ") + "}\n");

    string $poseSetting = extractPoseSetting($poseTransform);
    print("    poseSetting    :" + $poseSetting + "\n");
    int $pasteSetting[] = extractPasteSetting($poseSetting);
    print("    pasteSetting   :{" + intArrayToString($pasteSetting, ", ") + "}\n");

    if ($isOpposite) {
      int $mirrorSetting[] = extractMirrorSetting($poseSetting);
      print("    mirrorSetting  :{" + intArrayToString($mirrorSetting, ", ") + "}\n");
      string $sourceParent = getParentNode($sourceNode);
      string $targetParent = getParentNode($targetNode);
      int $hasCommonParent = $sourceParent == $targetParent;
      print("    hasCommonParent:" + $hasCommonParent + "\n");
      $transformValues = mirrorTransform(
        $targetNode,
        $transformValues,
        $hasCommonParent,
        $mirrorSetting[0],
        $mirrorSetting[1],
        $mirrorSetting[2],
        $mirrorSetting[3],
        $mirrorSetting[4]
      );
    }
    else {
      $transformValues = asIsTransform($targetNode, $transformValues);
    }

    setTransformAttributes(
      $targetNode,
      $transformValues,
      $pasteSetting[0],
      $pasteSetting[1],
      $pasteSetting[2]
    );
  }
}

// オイラーからクォータニオンへの変換テスト
if (0) {
  string $roNames[] = {"XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"};
  float $jo[] = {-90, 0, 90};
  print("jo:{" + floatArrayToString($jo, ", ") + "}\n");
  for ($i = 0; $i < `size $roNames`; $i++) {
    int $o = reverseRotateOrder($i);
    float $joq[] = quatInverse(eulerToQuat($jo, $o));
    print($roNames[$i] + ":{" + floatArrayToString($joq, ", ") + "}\n");
  }
}

// 2022-mirror-transform-test.ma
if (1) {
  print("--------------------------------------------------------------------------------\n");

  string $axisNames[] = {"X", "Y", "Z"};
  string $planeNames[] = {"XY", "XZ", "YX", "YZ", "ZX", "ZY"};
  int $mirrorAxes[] = {0, 1, 2};
  int $primaryAxes[] = {0, 0, 1, 1, 2, 2};
  int $secondaryAxes[] = {1, 2, 0, 2, 0, 1};

  // default:{0, 1, 2}
  int $axisFlags[] = {0, 1, 2};
  // default:{0, 1, 2, 3, 4, 5}
  int $planeFlags[] = {0, 1, 2, 3, 4, 5};
  // default:{0, 1, 2}
  int $depthFlags[] = {0, 1, 2};

  string $roNames[] = {"XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"};
  int $rotateOrder = 0;

  int $isOpposite = 0;
  int $pasteSetting[] = {1, 1, 0};
  string $selectSetting[] = {"_L", "_R"};
  int $mirrorSetting[] = {0, 0, 1, 0, 0};

  for ($i = 0; $i < `size $axisFlags`; $i++) {
    int $axisIndex = $axisFlags[$i];
    $mirrorSetting[0] = $mirrorAxes[$axisIndex];
    for ($j = 0; $j < `size $planeFlags`; $j++) {
      int $planeIndex = $planeFlags[$j];
      $mirrorSetting[1] = $primaryAxes[$planeIndex];
      $mirrorSetting[2] = $secondaryAxes[$planeIndex];

      string $poseSetting = buildPoseSetting(
        $pasteSetting, $selectSetting, $mirrorSetting
      );

      string $baseName = "|" + $axisNames[$axisIndex] + "|ROOT";
      string $nL = $baseName;
      string $nR = $baseName;
      for ($k = 0; $k < `size $depthFlags`; $k++) {
        clearPoses();

        int $depthIndex = $depthFlags[$k] + 1;
        $nL += "|" + $planeNames[$planeIndex] + "_L" + $depthIndex;
        $nR += "|" + $planeNames[$planeIndex] + "_R" + $depthIndex;

        print("--------------------------------------------------------------------------------\n");
        print("nL[" + `objExists $nL` + "]:" + $nL + "\n");
        print("nR[" + `objExists $nR` + "]:" + $nR + "\n");

        setAttr ($nL + ".rotateOrder") $rotateOrder;
        select -r $nL;
        addPose("a", {$nL}, {$poseSetting});

        setAttr ($nR + ".rotateOrder") $rotateOrder;
        select -r $nR;
        pastePose(0, $isOpposite, {$nR});
      }
    }
  }

  print("--------------------------------------------------------------------------------\n");
}

/*
eval ("source \"" + `getenv "MAYA_APP_DIR"` + "/library/nkCopyPose/nkCopyPoseCoreTest.mel\"");
*/
